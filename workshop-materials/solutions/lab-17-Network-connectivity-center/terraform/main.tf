# main.tf for Lab 17: Network Connectivity Center Implementation
# Generated by Copilot

terraform {
  required_version = ">= 1.0"
  required_providers {
    google = {
      source  = "hashicorp/google"
      version = "~> 4.0"
    }
  }
}

provider "google" {
  project = var.project_id
  region  = var.region
  zone    = var.zone
}

# Enable required APIs for Network Connectivity Center
resource "google_project_service" "ncc_apis" {
  count   = length(var.required_apis)
  project = var.project_id
  service = var.required_apis[count.index]

  disable_dependent_services = true
  disable_on_destroy         = false
}

# Network Connectivity Center Hub
resource "google_network_connectivity_hub" "ncc_hub" {
  count       = var.create_ncc_hub ? 1 : 0
  name        = var.ncc_hub_name
  project     = var.project_id
  description = var.hub_description
  labels      = var.hub_labels

  depends_on = [google_project_service.ncc_apis]
}

# VPC Networks for spokes (if creating sample spokes)
resource "google_compute_network" "spoke_networks" {
  count                   = var.create_sample_spokes ? length(var.sample_spoke_configs) : 0
  name                    = var.sample_spoke_configs[count.index].name
  project                 = var.project_id
  auto_create_subnetworks = false
  routing_mode           = var.enable_global_routing ? "GLOBAL" : "REGIONAL"

  depends_on = [google_project_service.ncc_apis]
}

# Subnets for sample spoke networks
resource "google_compute_subnetwork" "spoke_subnets" {
  count         = var.create_sample_spokes ? length(var.sample_spoke_configs) : 0
  name          = "${var.sample_spoke_configs[count.index].name}-subnet"
  project       = var.project_id
  network       = google_compute_network.spoke_networks[count.index].id
  ip_cidr_range = var.sample_spoke_configs[count.index].subnet_cidr
  region        = var.region

  # Enable private Google access
  private_ip_google_access = var.enable_private_google_access

  # Secondary IP ranges if specified
  dynamic "secondary_ip_range" {
    for_each = var.sample_spoke_configs[count.index].secondary_ranges
    content {
      range_name    = secondary_ip_range.value.range_name
      ip_cidr_range = secondary_ip_range.value.ip_cidr_range
    }
  }
}

# Router for Cloud NAT (for sample spokes)
resource "google_compute_router" "spoke_routers" {
  count   = var.create_sample_spokes ? length(var.sample_spoke_configs) : 0
  name    = "${var.sample_spoke_configs[count.index].name}-router"
  project = var.project_id
  region  = var.region
  network = google_compute_network.spoke_networks[count.index].id
}

# Cloud NAT for outbound internet access
resource "google_compute_router_nat" "spoke_nats" {
  count                              = var.create_sample_spokes ? length(var.sample_spoke_configs) : 0
  name                               = "${var.sample_spoke_configs[count.index].name}-nat"
  project                           = var.project_id
  router                            = google_compute_router.spoke_routers[count.index].name
  region                            = var.region
  nat_ip_allocate_option            = "AUTO_ONLY"
  source_subnetwork_ip_ranges_to_nat = "ALL_SUBNETWORKS_ALL_IP_RANGES"

  log_config {
    enable = var.enable_nat_logging
    filter = "ERRORS_ONLY"
  }
}

# Network Connectivity Center Spokes for existing networks
resource "google_network_connectivity_spoke" "existing_spokes" {
  count    = length(var.existing_spoke_networks)
  name     = "${var.existing_spoke_networks[count.index]}-spoke"
  project  = var.project_id
  location = var.region
  hub      = var.create_ncc_hub ? google_network_connectivity_hub.ncc_hub[0].id : var.existing_hub_id

  linked_vpc_network {
    uri                = "projects/${var.project_id}/global/networks/${var.existing_spoke_networks[count.index]}"
    exclude_export_ranges = var.exclude_export_ranges
  }

  labels = var.spoke_labels
}

# Network Connectivity Center Spokes for sample networks
resource "google_network_connectivity_spoke" "sample_spokes" {
  count    = var.create_sample_spokes ? length(var.sample_spoke_configs) : 0
  name     = "${var.sample_spoke_configs[count.index].name}-spoke"
  project  = var.project_id
  location = var.region
  hub      = var.create_ncc_hub ? google_network_connectivity_hub.ncc_hub[0].id : var.existing_hub_id

  linked_vpc_network {
    uri                = google_compute_network.spoke_networks[count.index].id
    exclude_export_ranges = var.exclude_export_ranges
  }

  labels = var.spoke_labels

  depends_on = [google_compute_network.spoke_networks]
}

# Firewall rules for inter-spoke communication
resource "google_compute_firewall" "inter_spoke_allow" {
  count   = var.create_sample_spokes ? length(var.sample_spoke_configs) : 0
  name    = "${var.sample_spoke_configs[count.index].name}-allow-inter-spoke"
  project = var.project_id
  network = google_compute_network.spoke_networks[count.index].name

  allow {
    protocol = "tcp"
    ports    = var.allowed_tcp_ports
  }

  allow {
    protocol = "udp"
    ports    = var.allowed_udp_ports
  }

  allow {
    protocol = "icmp"
  }

  source_ranges = var.allowed_ip_ranges
  target_tags   = var.network_tags
}

# Custom firewall rules
resource "google_compute_firewall" "custom_rules" {
  count   = length(var.custom_firewall_rules)
  name    = var.custom_firewall_rules[count.index].name
  project = var.project_id
  network = var.custom_firewall_rules[count.index].network

  dynamic "allow" {
    for_each = var.custom_firewall_rules[count.index].allow_rules
    content {
      protocol = allow.value.protocol
      ports    = allow.value.ports
    }
  }

  dynamic "deny" {
    for_each = var.custom_firewall_rules[count.index].deny_rules
    content {
      protocol = deny.value.protocol
      ports    = deny.value.ports
    }
  }

  source_ranges      = var.custom_firewall_rules[count.index].source_ranges
  destination_ranges = var.custom_firewall_rules[count.index].destination_ranges
  source_tags        = var.custom_firewall_rules[count.index].source_tags
  target_tags        = var.custom_firewall_rules[count.index].target_tags
  priority           = var.custom_firewall_rules[count.index].priority
}

# IAM bindings for Network Connectivity Center
resource "google_project_iam_binding" "ncc_admins" {
  count   = length(var.ncc_admin_members) > 0 ? 1 : 0
  project = var.project_id
  role    = "roles/networkconnectivity.hubAdmin"
  members = var.ncc_admin_members
}

resource "google_project_iam_binding" "ncc_viewers" {
  count   = length(var.ncc_viewer_members) > 0 ? 1 : 0
  project = var.project_id
  role    = "roles/networkconnectivity.hubViewer"
  members = var.ncc_viewer_members
}

# Monitoring policy for NCC (if enabled)
resource "google_monitoring_alert_policy" "ncc_spoke_disconnected" {
  count        = var.enable_monitoring ? 1 : 0
  display_name = "NCC Spoke Disconnected"
  project      = var.project_id

  conditions {
    display_name = "Spoke connection state"
    
    condition_threshold {
      filter          = "resource.type=\"gce_network_connectivity_spoke\""
      comparison      = "COMPARISON_EQUAL"
      threshold_value = 0
      duration        = "300s"
      
      aggregations {
        alignment_period   = "300s"
        per_series_aligner = "ALIGN_MEAN"
      }
    }
  }

  alert_strategy {
    auto_close = "1800s"
  }

  notification_channels = var.notification_channels

  documentation {
    content   = "A Network Connectivity Center spoke has been disconnected."
    mime_type = "text/markdown"
  }
}
